// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

define("deferred", function () { return (function (modules) {
	var resolve, getRequire, require, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]};
	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullpath, state) {
		var name, dir, exports, module, fn, found, i, ext;
		path = path.split('/');
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
			} else {
				tree.push(scope);
				scope = scope[dir];
			}
			if (!scope) throw notFoundError(fullpath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullpath, 1);
			}
			return resolve(scope, tree, 'index', fullpath, 2);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullpath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports };
		fn.call(exports, exports, module, getRequire(scope, tree));
		return module.exports;
	};
	require = function (scope, tree, fullpath) {
		var name, path = fullpath, t = fullpath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) throw notFoundError(fullpath);
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullpath, state);
	};
	getRequire = function (scope, tree) {
		return function (path) { return require(scope, [].concat(tree), path); };
	};
	return getRequire(modules, []);
})({
	"deferred": {
		"lib": {
			"_ext.js": function (exports, module, require) {
				'use strict';

				var callable   = require('es5-ext/lib/Object/valid-callable')
				  , d          = require('es5-ext/lib/Object/descriptor')
				  , isCallable = require('es5-ext/lib/Object/is-callable')
				  , ee         = require('event-emitter/lib/core')
				  , isPromise  = require('./is-promise')

				  , create = Object.create, defineProperty = Object.defineProperty, deferred
				  , doneFn;

				module.exports = exports = function (name, unres, onres, res) {
					name = String(name);
					callable(res) && ((onres == null) || callable(onres)) && callable(unres);
					defineProperty(exports._unresolved, name, d(unres));
					exports._onresolve[name] = onres;
					defineProperty(exports._resolved, name, d(res));
					exports._names.push(name);
				};

				exports._names = ['end', 'then', 'valueOf'];

				exports._unresolved = ee(create(Function.prototype, {
					then: d(function (win, fail) {
						var def;
						if (!this.pending) this.pending = [];
						def = deferred();
						this.pending.push('then', [win, fail, def.resolve]);
						return def.promise;
					}),
					done: d(doneFn = function (win, fail) {
						(win == null) || callable(win);
						(fail == null) || callable(fail);
						if (!this.pending) this.pending = [];
						this.pending.push('done', arguments);
					}),
					end: d(doneFn),
					resolved: d(false),
					returnsPromise: d(true),
					valueOf: d(function () { return this; })
				}));

				exports._onresolve = {
					then: function (win, fail, resolve) {
						var value, cb = this.failed ? fail : win;
						if (cb == null) {
							resolve(this.value);
							return;
						}
						if (isCallable(cb)) {
							if (isPromise(cb)) {
								if (cb.resolved) {
									resolve(cb.value);
									return;
								}
								cb.end(resolve, resolve);
								return;
							}
							try { value = cb(this.value); } catch (e) { value = e; }
							resolve(value);
							return;
						}
						resolve(cb);
					},
					done: doneFn = function (win, fail) {
						if (this.failed) {
							if (fail) {
								fail(this.value);
								return;
							}
							throw this.value;
						}
						if (win) win(this.value);
					},
					end: doneFn
				};

				exports._resolved = ee(create(Function.prototype, {
					then: d(function (win, fail) {
						var value, cb = this.failed ? fail : win;
						if (cb == null) {
							return this;
						}
						if (isCallable(cb)) {
							if (isPromise(cb)) return cb;
							try { value = cb(this.value); } catch (e) { value = e; }
							return deferred(value);
						}
						return deferred(cb);
					}),
					done: d(doneFn = function (win, fail) {
						(win == null) || callable(win);
						(fail == null) || callable(fail);
						if (this.failed) {
							if (fail) {
								fail(this.value);
								return;
							}
							throw this.value;
						}
						if (win) win(this.value);
					}),
					end: d(doneFn),
					resolved: d(true),
					returnsPromise: d(true),
					valueOf: d(function () { return this.value; })
				}));

				deferred = require('./deferred');
				deferred.extend = exports;
			},
			"deferred.js": function (exports, module, require) {
				// Returns function that returns deferred or promise object.
				//
				// 1. If invoked without arguments then deferred object is returned
				//    Deferred object consist of promise (unresolved) function and resolve
				//    function through which we resolve promise
				// 2. If invoked with one argument then promise is returned which resolved value
				//    is given argument. Argument may be any value (even undefined),
				//    if it's promise then same promise is returned
				// 3. If invoked with more than one arguments then promise that resolves with
				//    array of all resolved arguments is returned.

				'use strict';

				var isError    = require('es5-ext/lib/Error/is-error')
				  , validError = require('es5-ext/lib/Error/valid-error')
				  , noop       = require('es5-ext/lib/Function/noop')
				  , isPromise  = require('./is-promise')

				  , every = Array.prototype.every, push = Array.prototype.push

				  , Deferred, createDeferred, count = 0, timeout, extendShim, ext
				  , protoSupported = Boolean(isPromise.__proto__);

				extendShim = function (promise) {
					ext._names.forEach(function (name) {
						promise[name] = function () {
							return promise.__proto__[name].apply(promise, arguments);
						};
					});
					promise.returnsPromise = true;
					promise.resolved = promise.__proto__.resolved;
				};

				Deferred = function () {
					var promise = function (win, fail) { return promise.then(win, fail); };
					if (!count) {
						timeout = setTimeout(noop, 1e9);
					}
					++count;
					if (createDeferred._monitor) {
						promise.monitor = createDeferred._monitor();
					}
					promise.__proto__ = ext._unresolved;
					if (!protoSupported) { extendShim(promise); }
					createDeferred._profile && createDeferred._profile();
					this.promise = promise;
					this.resolve = this.resolve.bind(this);
					this.reject = this.reject.bind(this);
				};

				Deferred.prototype = {
					resolved: false,
					resolve: function (value) {
						var i, name, data;
						if (this.resolved) {
							return this.promise;
						}
						this.resolved = true;
						if (!--count) {
							clearTimeout(timeout);
						}
						if (this.promise.monitor) {
							clearTimeout(this.promise.monitor);
						}
						if (isPromise(value)) {
							if (!value.resolved) {
								if (!value.dependencies) {
									value.dependencies = [];
								}
								value.dependencies.push(this.promise);
								if (this.promise.pending) {
									if (value.pending) {
										push.apply(value.pending, this.promise.pending);
										this.promise.pending = value.pending;
										if (this.promise.dependencies) {
											this.promise.dependencies.forEach(function self(dPromise) {
												dPromise.pending = value.pending;
												if (dPromise.dependencies) {
													dPromise.dependencies.forEach(self);
												}
											});
										}
									} else {
										value.pending = this.promise.pending;
									}
								} else if (value.pending) {
									this.promise.pending = value.pending;
								} else {
									this.promise.pending = value.pending = [];
								}
								return this.promise;
							} else {
								value = value.value;
							}
						}
						this.promise.value = value;
						this.promise.failed = (value && isError(value)) || false;
						this.promise.__proto__ = ext._resolved;
						if (!protoSupported) {
							this.promise.resolved = true;
						}
						if (this.promise.dependencies) {
							this.promise.dependencies.forEach(function self(dPromise) {
								dPromise.value = value;
								dPromise.failed = this.failed;
								dPromise.__proto__ = ext._resolved;
								if (!protoSupported) {
									dPromise.resolved = true;
								}
								delete dPromise.pending;
								if (dPromise.dependencies) {
									dPromise.dependencies.forEach(self, this);
									delete dPromise.dependencies;
								}
							}, this.promise);
							delete this.promise.dependencies;
						}
						if ((data = this.promise.pending)) {
							for (i = 0; (name = data[i]); ++i) {
								ext._onresolve[name].apply(this.promise, data[++i]);
							}
							delete this.promise.pending;
						}
						return this.promise;
					},
					reject: function (error) { return this.resolve(validError(error)); }
				};

				module.exports = createDeferred = function (value) {
					var l, d, waiting, initialized, result, promise;
					if ((l = arguments.length)) {
						if (l > 1) {
							d = new Deferred();
							waiting = 0;
							result = new Array(l);
							every.call(arguments, function (value, index) {
								if (isPromise(value)) {
									++waiting;
									value.end(function (value) {
										result[index] = value;
										if (!--waiting && initialized) {
											d.resolve(result);
										}
									}, d.resolve);
								} else if (isError(value)) {
									d.resolve(value);
									return false;
								} else {
									result[index] = value;
								}
								return true;
							});
							initialized = true;
							if (!waiting) {
								d.resolve(result);
							}
							return d.promise;
						} else if (isPromise(value)) {
							return value;
						} else {
							promise = function (win, fail) { return promise.then(win, fail); };
							promise.value = value;
							promise.failed = isError(value);
							promise.__proto__ = ext._resolved;
							if (!protoSupported) { extendShim(promise); }
							createDeferred._profile && createDeferred._profile(true);
							return promise;
						}
					}
					return new Deferred();
				};

				createDeferred.Deferred = Deferred;
				ext = require('./_ext');
			},
			"ext": {
				"_process-arguments.js": function (exports, module, require) {
					'use strict';

					var arrayOf   = require('es5-ext/lib/Array/of')
					  , deferred  = require('../deferred')
					  , isPromise = require('../is-promise')

					  , push = Array.prototype.push, slice = Array.prototype.slice;

					module.exports = function (args, length) {
						var i, l;
						if ((length != null) && (args.length !== length)) {
							args = slice.call(args, 0, length);
							if (args.length < length) {
								push.apply(args, new Array(length - args.length));
							}
						}
						for (i = 0, l = args.length; i < l; ++i) {
							if (isPromise(args[i])) {
								if (args[i].resolved) {
									if (args[i].failed) {
										return args[i];
									}
									args[i] = args[i].value;
								} else if (l > 1) {
									return deferred.apply(null, args);
								} else {
									return args[0](arrayOf);
								}
							}
						}
						return args;
					};
				},
				"array": {
					"map.js": function (exports, module, require) {
						// Promise aware Array's map

						'use strict';

						var isError   = require('es5-ext/lib/Error/is-error')
						  , extend    = require('es5-ext/lib/Object/extend')
						  , value     = require('es5-ext/lib/Object/valid-value')
						  , callable  = require('es5-ext/lib/Object/valid-callable')
						  , deferred  = require('../../deferred')
						  , isPromise = require('../../is-promise')

						  , every = Array.prototype.every
						  , call = Function.prototype.call;

						var DMap = function (list, cb, context) {
							this.list = list;
							this.cb = cb;
							this.context = context;
							this.result = new Array(list.length >>> 0);

							extend(this, deferred());
							every.call(list, this.process, this);
							if (!this.waiting) {
								return this.resolve(this.result);
							}
							this.initialized = true;

							return this.promise;
						};

						DMap.prototype = {
							waiting: 0,
							initialized: false,
							process: function (value, index) {
								++this.waiting;
								if (isPromise(value)) {
									if (!value.resolved) {
										value.end(this.processCb.bind(this, index), this.resolve);
										return true;
									}
									value = value.value;
									if (isError(value)) {
										this.resolve(value);
										return false;
									}
								} else if (isError(value) && !this.cb) {
									this.resolve(value);
									return false;
								}
								return this.processCb(index, value);
							},
							processCb: function (index, value) {
								if (this.promise.resolved) {
									return false;
								}
								if (this.cb) {
									try {
										value = call.call(this.cb, this.context, value, index, this.list);
									} catch (e) {
										this.resolve(e);
										return false;
									}
									if (isPromise(value)) {
										if (!value.resolved) {
											value.end(this.processValue.bind(this, index), this.resolve);
											return true;
										}
										value = value.value;
									}
									if (isError(value)) {
										this.resolve(value);
										return false;
									}
								}
								this.processValue(index, value);
								return true;
							},
							processValue: function (index, value) {
								if (this.promise.resolved) {
									return;
								}
								this.result[index] = value;
								if (!--this.waiting && this.initialized) {
									this.resolve(this.result);
								}
							}
						};

						module.exports = function (cb/*, thisArg*/) {
							value(this);
							(cb == null) || callable(cb);

							return new DMap(this, cb, arguments[1]);
						};
					},
					"reduce.js": function (exports, module, require) {
						// Promise aware Array's reduce

						'use strict';

						var isError   = require('es5-ext/lib/Error/is-error')
						  , extend    = require('es5-ext/lib/Object/extend')
						  , value     = require('es5-ext/lib/Object/valid-value')
						  , callable  = require('es5-ext/lib/Object/valid-callable')
						  , deferred  = require('../../deferred')
						  , isPromise = require('../../is-promise')

						  , call = Function.prototype.call;

						var Reduce = function (list, cb, initial, initialized) {
							this.list = list;
							this.cb = cb;
							this.initialized = initialized;
							this.length = list.length >>> 0;

							if (isPromise(initial)) {
								if (!initial.resolved) {
									extend(this, deferred());
									initial.end(function (initial) {
										this.value = initial;
										this.init();
									}.bind(this), this.resolve);
									return this.promise;
								}
								this.value = initial.value;
								if (isError(this.value)) {
									return initial;
								}
							} else {
								this.value = initial;
							}

							return this.init();
						};

						Reduce.prototype = {
							current: 0,
							init: function () {
								while (this.current < this.length) {
									if (this.current in this.list) {
										if (!this.promise) {
											extend(this, deferred());
										}
										this.processCb = this.processCb.bind(this);
										this.processValue = this.processValue.bind(this);
										this.process();
										return this.promise;
									}
									++this.current;
								}
								if (!this.initialized) {
									throw new Error("Reduce of empty array with no initial value");
								}
								return this.resolve ? this.resolve(this.value) : deferred(this.value);
							},
							process: function () {
								var value = this.list[this.current];
								if (isPromise(value)) {
									if (!value.resolved) {
										value.end(this.processCb, this.resolve);
										return;
									}
									value = value.value;
									if (isError(value)) {
										this.resolve(value);
										return;
									}
								} else if (isError(value) && !this.cb) {
									this.resolve(value);
									return;
								}
								this.processCb(value);
							},
							processCb: function (value) {
								if (!this.initialized) {
									this.initialized = true;
									this.processValue(value);
									return;
								}
								if (this.cb) {
									try {
										value = call.call(this.cb, undefined, this.value, value, this.current,
											this.list);
									} catch (e) {
										this.resolve(e);
										return;
									}
									if (isPromise(value)) {
										if (!value.resolved) {
											value.end(this.processValue, this.resolve);
											return;
										}
										value = value.value;
									}
									if (isError(value)) {
										this.resolve(value);
										return;
									}
								}
								this.processValue(value);
							},
							processValue: function (value) {
								this.value = value;
								while (++this.current < this.length) {
									if (this.current in this.list) {
										this.process();
										return;
									}
								}
								this.resolve(this.value);
							}
						};

						module.exports = function (cb/*, initial*/) {
							value(this);
							(cb == null) || callable(cb);

							return new Reduce(this, cb, arguments[1], arguments.length > 1);
						};
					},
					"some.js": function (exports, module, require) {
						// Promise aware Array's some

						'use strict';

						var isError   = require('es5-ext/lib/Error/is-error')
						  , extend    = require('es5-ext/lib/Object/extend')
						  , value     = require('es5-ext/lib/Object/valid-value')
						  , callable  = require('es5-ext/lib/Object/valid-callable')
						  , deferred  = require('../../deferred')
						  , isPromise = require('../../is-promise')

						  , call = Function.prototype.call;

						var Some = function (list, cb, context) {
							this.list = list;
							this.cb = cb;
							this.context = context;
							this.length = list.length >>> 0;

							while (this.current < this.length) {
								if (this.current in list) {
									extend(this, deferred());
									this.processCb = this.processCb.bind(this);
									this.processValue = this.processValue.bind(this);
									this.process();
									return this.promise;
								}
								++this.current;
							}
							return deferred(false);
						};

						Some.prototype = {
							current: 0,
							process: function () {
								var value = this.list[this.current];
								if (isPromise(value)) {
									if (!value.resolved) {
										value.end(this.processCb, this.resolve);
										return;
									}
									value = value.value;
									if (isError(value)) {
										this.resolve(value);
										return;
									}
								} else if (isError(value) && !this.cb) {
									this.resolve(value);
									return;
								}
								this.processCb(value);
							},
							processCb: function (value) {
								if (this.cb) {
									try {
										value = call.call(this.cb, this.context, value, this.current,
											this.list);
									} catch (e) {
										this.resolve(e);
										return;
									}
									if (isPromise(value)) {
										if (!value.resolved) {
											value.end(this.processValue, this.resolve);
											return;
										}
										value = value.value;
									}
									if (isError(value)) {
										this.resolve(value);
										return;
									}
								}
								this.processValue(value);
							},
							processValue: function (value) {
								if (value) {
									this.resolve(true);
									return;
								}
								while (++this.current < this.length) {
									if (this.current in this.list) {
										this.process();
										return;
									}
								}
								this.resolve(false);
							}
						};

						module.exports = function (cb/*, thisArg*/) {
							value(this);
							(cb == null) || callable(cb);

							return new Some(this, cb, arguments[1]);
						};
					}
				},
				"function": {
					"delay.js": function (exports, module, require) {
						// Delay function execution, return promise for delayed function result

						'use strict';

						var apply    = Function.prototype.apply
						  , callable = require('es5-ext/lib/Object/valid-callable')
						  , deferred = require('../../deferred');

						var delayed = function (fn, args, resolve) {
							var value;
							try {
								value = apply.call(fn, this, args);
							} catch (e) {
								value = e;
							}
							resolve(value);
						};

						module.exports = function (timeout) {
							var fn, result;
							fn = callable(this);
							result = function () {
								var def = deferred();
								setTimeout(delayed.bind(this, fn, arguments, def.resolve), timeout);
								return def.promise;
							};
							result.returnsPromise = true;
							return result;
						};
					},
					"gate.js": function (exports, module, require) {
						// Limit number of concurrent function executions (to cLimit number).
						// Limited calls are queued. Optionaly maximum queue length can also be
						// controlled with qLimit value, any calls that would reach over that limit
						// would be discarded (its promise would resolve with "Too many calls" error)

						'use strict';

						var toUint    = require('es5-ext/lib/Number/to-uint')
						  , callable  = require('es5-ext/lib/Object/valid-callable')
						  , eeUnify   = require('event-emitter/lib/unify')
						  , deferred  = require('../../deferred')
						  , isPromise = require('../../is-promise')

						  , apply = Function.prototype.apply, max = Math.max

						  , reject;

						require('../promise/finally');

						reject = function () {
							var e = new Error("Too many calls");
							e.type = 'deferred-gate-rejected';
							return deferred(e);
						};

						module.exports = function (cLimit, qLimit) {
							var fn, count, decrement, unload, queue, run, result;
							fn = callable(this);
							cLimit = max(toUint(cLimit), 1);
							qLimit = ((qLimit == null) || isNaN(qLimit)) ? Infinity : toUint(qLimit);
							count = 0;
							queue = [];

							run = function (thisArg, args, def) {
								var r;
								try {
									r = apply.call(fn, thisArg, args);
								} catch (e) {
									r = e;
								}
								if (isPromise(r)) {
									if (def) eeUnify(def.promise, r);
									if (!r.resolved) {
										++count;
										if (def) def.resolve(r);
										return r.finally(decrement);
									} else {
										r = r.value;
									}
								}
								if (!def) return deferred(r);
								def.resolve(r);
								unload();
							};

							decrement = function () {
								--count;
								unload();
							};

							unload = function () {
								var data;
								if ((data = queue.shift())) run.apply(null, data);
							};

							result = function () {
								var def;
								if (count >= cLimit) {
									if (queue.length < qLimit) {
										def = deferred();
										queue.push([this, arguments, def]);
										return def.promise;
									}
									return reject();
								}
								return run(this, arguments);
							};
							result.returnsPromise = true;
							return result;
						};
					},
					"promisify-sync.js": function (exports, module, require) {
						// Promisify synchronous function

						'use strict';

						var callable         = require('es5-ext/lib/Object/valid-callable')
						  , deferred         = require('../../deferred')
						  , isPromise        = require('../../is-promise')
						  , processArguments = require('../_process-arguments')

						  , apply = Function.prototype.apply

						  , applyFn;

						applyFn = function (fn, args, resolve) {
							var value;
							try {
								value = apply.call(fn, this, args);
							} catch (e) {
								value = e;
							}
							resolve(value);
						};

						module.exports = function (length) {
							var fn, result;
							fn = callable(this);
							if (fn.returnsPromise) {
								return fn;
							}
							if (length != null) {
								length = length >>> 0;
							}
							result = function () {
								var args, def;
								args = processArguments(arguments, length);

								if (isPromise(args)) {
									if (args.failed) {
										return args;
									}
									def = deferred();
									args.end(function (args) {
										apply.call(this, fn, args, def.resolve);
									}.bind(this), def.resolve);
								} else {
									def = deferred();
									applyFn.call(this, fn, args, def.resolve);
								}

								return def.promise;
							};
							result.returnsPromise = true;
							return result;
						};
					},
					"promisify.js": function (exports, module, require) {
						// Promisify asynchronous function

						'use strict';

						var toArray          = require('es5-ext/lib/Array/from')
						  , callable         = require('es5-ext/lib/Object/valid-callable')
						  , deferred         = require('../../deferred')
						  , isPromise        = require('../../is-promise')
						  , processArguments = require('../_process-arguments')

						  , slice = Array.prototype.slice, apply = Function.prototype.apply

						  , applyFn;

						applyFn = function (fn, args, resolve) {
							args = toArray(args);
							apply.call(fn,  this, args.concat(function (error, result) {
								if (error == null) {
									resolve((arguments.length > 2) ? slice.call(arguments, 1) : result);
								} else {
									resolve(error);
								}
							}));
						};

						module.exports = function (length) {
							var fn, result;
							fn = callable(this);
							if (fn.returnsPromise) {
								return fn;
							}
							if (length != null) {
								length = length >>> 0;
							}
							result = function () {
								var args, def;
								args = processArguments(arguments, length);

								if (isPromise(args)) {
									if (args.failed) {
										return args;
									}
									def = deferred();
									args.end(function (args) {
										try {
											applyFn.call(this, fn, args, def.resolve);
										} catch (e) {
											def.resolve(e);
										}
									}.bind(this), def.resolve);
								} else {
									def = deferred();
									try {
										applyFn.call(this, fn, args, def.resolve);
									} catch (e) {
										def.resolve();
										throw e;
									}
								}

								return def.promise;
							};
							result.returnsPromise = true;
							return result;
						};
					}
				},
				"promise": {
					"_array.js": function (exports, module, require) {
						// Used by promise extensions that are based on array extensions.

						'use strict';

						var callable = require('es5-ext/lib/Object/valid-callable')
						  , deferred = require('../../deferred');

						module.exports = function (name, ext) {
							deferred.extend(name, function (cb) {
								var def;
								(cb == null) || callable(cb);
								if (!this.pending) {
									this.pending = [];
								}
								def = deferred();
								this.pending.push(name, [arguments, def.resolve]);
								return def.promise;
							}, function (args, resolve) {
								var result;
								if (this.failed) {
									resolve(this.value);
								} else {
									try {
										result = ext.apply(this.value, args);
									} catch (e) {
										result = e;
									}
									resolve(result);
								}
							}, function (cb) {
								(cb == null) || callable(cb);
								if (this.failed) {
									return this;
								} else {
									try {
										return ext.apply(this.value, arguments);
									} catch (e) {
										return deferred(e);
									}
								}
							});
						};
					},
					"aside.js": function (exports, module, require) {
						// 'aside' - Promise extension
						//
						// promise.aside(win, fail)
						//
						// Works in analogous way as promise function itself (or `then`)
						// but instead of adding promise to promise chain it returns context promise and
						// lets callback carry on with other processing logic

						'use strict';

						var callable = require('es5-ext/lib/Object/valid-callable')
						  , deferred = require('../../deferred');

						deferred.extend('aside', function (win, fail) {
							(win == null) || callable(win);
							(fail == null) || callable(fail);
							if (win || fail) {
								if (!this.pending) {
									this.pending = [];
								}
								this.pending.push('aside', arguments);
							}
							return this;
						}, function (win, fail) {
							var cb = this.failed ? fail : win;
							if (cb) {
								cb(this.value);
							}
						}, function (win, fail) {
							var cb;
							(win == null) || callable(win);
							(fail == null) || callable(fail);
							cb = this.failed ? fail : win;
							if (cb) {
								cb(this.value);
							}
							return this;
						});
					},
					"catch.js": function (exports, module, require) {
						// 'catch' - Promise extension
						//
						// promise.catch(cb)
						//
						// Same as `then` but accepts only onFail callback

						'use strict';

						var isCallable = require('es5-ext/lib/Object/is-callable')
						  , validValue = require('es5-ext/lib/Object/valid-value')
						  , deferred   = require('../../deferred')
						  , isPromise  = require('../../is-promise');

						deferred.extend('catch', function (cb) {
							var def;
							validValue(cb);
							if (!this.pending) this.pending = [];
							def = deferred();
							this.pending.push('catch', [cb, def.resolve]);
							return def.promise;
						}, function (cb, resolve) {
							var value;
							if (!this.failed) {
								resolve(this.value);
								return;
							}
							if (isCallable(cb)) {
								if (isPromise(cb)) {
									if (cb.resolved) resolve(cb.value);
									else cb.done(resolve, resolve);
									return;
								}
								try { value = cb(this.value); } catch (e) { value = e; }
								resolve(value);
								return;
							}
							resolve(cb);
						}, function (cb) {
							var value;
							validValue(cb);
							if (!this.failed) return this;
							if (isCallable(cb)) {
								if (isPromise(cb)) return cb;
								try { value = cb(this.value); } catch (e) { value = e; }
								return deferred(value);
							}
							return deferred(cb);
						});
					},
					"cb.js": function (exports, module, require) {
						// 'cb' - Promise extension
						//
						// promise.cb(cb)
						//
						// Handles asynchronous function style callback (which is run in next event loop
						// the earliest). Returns self promise. Callback is optional.
						//
						// Useful when we want to configure typical asynchronous function which logic is
						// internally configured with promises.
						//
						// Extension can be used as follows:
						//
						// var foo = function (arg1, arg2, cb) {
						//     var d = deferred();
						//     // ... implementation
						//     return d.promise.cb(cb);
						// };
						//
						// `cb` extension returns promise and handles eventual callback (optional)

						'use strict';

						var callable   = require('es5-ext/lib/Object/valid-callable')
						  , nextTick   = require('next-tick')
						  , deferred   = require('../../deferred');

						deferred.extend('cb', function (cb) {
							if (cb == null) {
								return this;
							}
							callable(cb);
							nextTick(function () {
								if (this.resolved) {
									if (this.failed) {
										cb(this.value);
									} else {
										cb(null, this.value);
									}
								} else {
									if (!this.pending) {
										this.pending = [];
									}
									this.pending.push('cb', [cb]);
								}
							}.bind(this));
							return this;
						}, function (cb) {
							if (this.failed) {
								cb(this.value);
							} else {
								cb(null, this.value);
							}
						}, function (cb) {
							if (cb == null) {
								return this;
							}
							callable(cb);
							nextTick(function () {
								if (this.failed) {
									cb(this.value);
								} else {
									cb(null, this.value);
								}
							}.bind(this));
							return this;
						});
					},
					"finally.js": function (exports, module, require) {
						// 'finally' - Promise extension
						//
						// promise.finally(cb)
						//
						// Called on promise resolution returns same promise, doesn't pass any values to
						// provided callback

						'use strict';

						var callable = require('es5-ext/lib/Object/valid-callable')
						  , deferred = require('../../deferred');

						deferred.extend('finally', function (cb) {
							callable(cb);
							if (!this.pending) this.pending = [];
							this.pending.push('finally', arguments);
							return this;
						}, function (cb) { cb(); }, function (cb) {
							callable(cb)();
							return this;
						});
					},
					"get.js": function (exports, module, require) {
						// 'get' - Promise extension
						//
						// promise.get(name)
						//
						// Resolves with property of resolved object

						'use strict';

						var value    = require('es5-ext/lib/Object/valid-value')
						  , deferred = require('../../deferred')

						  , reduce = Array.prototype.reduce;

						deferred.extend('get', function (/*…name*/) {
							var def;
							if (!this.pending) {
								this.pending = [];
							}
							def = deferred();
							this.pending.push('get', [arguments, def.resolve]);
							return def.promise;

						}, function (args, resolve) {
							var result;
							if (this.failed) {
								resolve(this.value);
							}
							try {
								result = reduce.call(args, function (obj, key) {
									return value(obj)[String(key)];
								}, this.value);
							} catch (e) {
								result = e;
							}
							return resolve(result);
						}, function (/*…name*/) {
							var result;
							if (this.failed) {
								return this;
							}
							try {
								result = reduce.call(arguments, function (obj, key) {
									return value(obj)[String(key)];
								}, this.value);
							} catch (e) {
								result = e;
							}
							return deferred(result);
						});
					},
					"invoke-async.js": function (exports, module, require) {
						// 'invokeAsync' - Promise extension
						//
						// promise.invokeAsync(name[, arg0[, arg1[, ...]]])
						//
						// On resolved object calls asynchronous method that takes callback
						// (Node.js style).
						// Do not pass callback, it's handled by internal implementation.
						// 'name' can be method name or method itself.

						'use strict';

						var toArray          = require('es5-ext/lib/Array/from')
						  , isCallable       = require('es5-ext/lib/Object/is-callable')
						  , deferred         = require('../../deferred')
						  , isPromise        = require('../../is-promise')
						  , processArguments = require('../_process-arguments')

						  , slice = Array.prototype.slice, apply = Function.prototype.apply

						  , applyFn;

						applyFn = function (fn, args, resolve) {
							var result;
							if (fn.returnsPromise) {
								try {
									result = apply.call(fn, this, args);
								} catch (e) {
									result = e;
								}
								return resolve(result);
							}
							args = toArray(args).concat(function (error, result) {
								if (error == null) {
									resolve((arguments.length > 2) ? slice.call(arguments, 1) : result);
								} else {
									resolve(error);
								}
							});
							try {
								apply.call(fn, this, args);
							} catch (e2) {
								resolve(e2);
							}
						};

						deferred.extend('invokeAsync', function (method/*, …args*/) {
							var def;
							if (!this.pending) {
								this.pending = [];
							}
							def = deferred();
							this.pending.push('invokeAsync', [arguments, def.resolve]);
							return def.promise;
						}, function (args, resolve) {
							var fn;
							if (this.failed) {
								resolve(this);
								return;
							}

							if (this.value == null) {
								resolve(new TypeError("Cannot use null or undefined"));
								return;
							}

							fn = args[0];
							if (!isCallable(fn)) {
								fn = String(fn);
								if (!isCallable(this.value[fn])) {
									resolve(new TypeError(fn + " is not a function"));
									return;
								}
								fn = this.value[fn];
							}

							args = processArguments(slice.call(args, 1));
							if (isPromise(args)) {
								if (args.failed) {
									resolve(args);
									return;
								}
								args.end(function (args) {
									applyFn.call(this, fn, args, resolve);
								}.bind(this.value), resolve);
							} else {
								applyFn.call(this.value, fn, args, resolve);
							}
						}, function (method/*, …args*/) {
							var args, def;
							if (this.failed) {
								return this;
							}

							if (this.value == null) {
								return deferred(new TypeError("Cannot use null or undefined"));
							}

							if (!isCallable(method)) {
								method = String(method);
								if (!isCallable(this.value[method])) {
									return deferred(new TypeError(method + " is not a function"));
								}
								method = this.value[method];
							}

							args = processArguments(slice.call(arguments, 1));
							if (isPromise(args)) {
								if (args.failed) {
									return args;
								}
								def = deferred();
								args.end(function (args) {
									applyFn.call(this, method, args, def.resolve);
								}.bind(this.value), def.resolve);
							} else if (method.returnsPromise) {
								return applyFn.call(this.value, method, args, deferred);
							} else {
								def = deferred();
								applyFn.call(this.value, method, args, def.resolve);
							}
							return def.promise;
						});
					},
					"invoke.js": function (exports, module, require) {
						// 'invoke' - Promise extension
						//
						// promise.invoke(name[, arg0[, arg1[, ...]]])
						//
						// On resolved object calls method that returns immediately.
						// 'name' can be method name or method itself.

						'use strict';

						var isCallable       = require('es5-ext/lib/Object/is-callable')
						  , deferred         = require('../../deferred')
						  , isPromise        = require('../../is-promise')
						  , processArguments = require('../_process-arguments')

						  , slice = Array.prototype.slice, apply = Function.prototype.apply

						  , applyFn;

						applyFn = function (fn, args) {
							try {
								return apply.call(fn, this, args);
							} catch (e) {
								return e;
							}
						};

						deferred.extend('invoke', function (method/*, …args*/) {
							var def;
							if (!this.pending) {
								this.pending = [];
							}
							def = deferred();
							this.pending.push('invoke', [arguments, def.resolve]);
							return def.promise;
						}, function (args, resolve) {
							var fn;
							if (this.failed) {
								resolve(this);
								return;
							}

							if (this.value == null) {
								resolve(new TypeError("Cannot use null or undefined"));
								return;
							}

							fn = args[0];
							if (!isCallable(fn)) {
								fn = String(fn);
								if (!isCallable(this.value[fn])) {
									resolve(new TypeError(fn + " is not a function"));
									return;
								}
								fn = this.value[fn];
							}

							args = processArguments(slice.call(args, 1));
							if (isPromise(args)) {
								if (args.failed) {
									resolve(args);
									return;
								}
								args.end(function (args) {
									resolve(applyFn.call(this, fn, args));
								}.bind(this.value), resolve);
							} else {
								resolve(applyFn.call(this.value, fn, args));
							}
						}, function (method/*, …args*/) {
							var args, def;
							if (this.failed) {
								return this;
							}

							if (this.value == null) {
								return deferred(new TypeError("Cannot use null or undefined"));
							}

							if (!isCallable(method)) {
								method = String(method);
								if (!isCallable(this.value[method])) {
									return deferred(new TypeError(method + " is not a function"));
								}
								method = this.value[method];
							}

							args = processArguments(slice.call(arguments, 1));
							if (isPromise(args)) {
								if (args.failed) {
									return args;
								}
								def = deferred();
								args.end(function (args) {
									def.resolve(applyFn.call(this, method, args));
								}.bind(this.value), def.resolve);
								return def.promise;
							} else {
								return deferred(applyFn.call(this.value, method, args));
							}
						});
					},
					"map.js": function (exports, module, require) {
						// 'map' - Promise extension
						//
						// promise.map(fn[, thisArg[, concurrentLimit]])
						//
						// Promise aware map for array-like results

						'use strict';

						require('./_array')('map', require('../array/map'));
					},
					"match.js": function (exports, module, require) {
						// 'match' - Promise extensions
						//
						// promise.match(onsuccess, onerror)
						//
						// Matches eventual list result onto function arguments,
						// otherwise works same as 'then' (promise function itself)

						'use strict';

						var match      = require('es5-ext/lib/Function/prototype/match')
						  , callable   = require('es5-ext/lib/Object/valid-callable')
						  , isCallable = require('es5-ext/lib/Object/is-callable')
						  , isPromise  = require('../../is-promise')
						  , deferred   = require('../../deferred');

						deferred.extend('match', function (win, fail) {
							var def;
							(win == null) || callable(win);
							if (!win && (fail == null)) {
								return this;
							}
							if (!this.pending) {
								this.pending = [];
							}
							def = deferred();
							this.pending.push('match', [win, fail, def.resolve]);
							return def.promise;
						}, function (win, fail, resolve) {
							var cb, value;
							cb = this.failed ? fail : win;
							if (cb == null) {
								resolve(this);
							}
							if (isCallable(cb)) {
								if (isPromise(cb)) {
									if (cb.resolved) {
										resolve(cb.value);
									} else {
										cb.end(resolve, resolve);
									}
									return;
								}
								if (!this.failed) {
									cb = match.call(cb);
								}
								try {
									value = cb(this.value);
								} catch (e) {
									value = e;
								}
								resolve(value);
							} else {
								resolve(cb);
							}
						}, function (win, fail) {
							var cb, value;
							cb = this.failed ? fail : win;
							if (cb == null) {
								return this;
							}
							if (isCallable(cb)) {
								if (isPromise(cb)) {
									return cb;
								}
								if (!this.failed) {
									cb = match.call(cb);
								}
								try {
									value = cb(this.value);
								} catch (e) {
									value = e;
								}
								return deferred(value);
							} else {
								return deferred(cb);
							}
						});
					},
					"reduce.js": function (exports, module, require) {
						// 'reduce' - Promise extension
						//
						// promise.reduce(fn[, initial])
						//
						// Promise aware reduce for array-like results

						'use strict';

						require('./_array')('reduce', require('../array/reduce'));
					},
					"some.js": function (exports, module, require) {
						// 'some' - Promise extension
						//
						// promise.some(fn[, thisArg])
						//
						// Promise aware some for array-like results

						'use strict';

						require('./_array')('some', require('../array/some'));
					}
				}
			},
			"index.js": function (exports, module, require) {
				// This construct deferred with all needed goodies that are being exported
				// when we import 'deferred' by main name.
				// All available promise extensions are also initialized.

				'use strict';

				var call   = Function.prototype.call
				  , extend = require('es5-ext/lib/Object/extend');

				module.exports = extend(require('./deferred'), {
					isPromise:     require('./is-promise'),
					validPromise:  require('./valid-promise'),
					delay:         call.bind(require('./ext/function/delay')),
					gate:          call.bind(require('./ext/function/gate')),
					monitor:       require('./monitor'),
					promisify:     call.bind(require('./ext/function/promisify')),
					promisifySync: call.bind(require('./ext/function/promisify-sync')),
					map:           call.bind(require('./ext/array/map')),
					reduce:        call.bind(require('./ext/array/reduce')),
					some:          call.bind(require('./ext/array/some'))
				}, require('./profiler'));

				require('./ext/promise/aside');
				require('./ext/promise/catch');
				require('./ext/promise/cb');
				require('./ext/promise/finally');
				require('./ext/promise/get');
				require('./ext/promise/invoke');
				require('./ext/promise/invoke-async');
				require('./ext/promise/map');
				require('./ext/promise/match');
				require('./ext/promise/some');
				require('./ext/promise/reduce');
			},
			"is-promise.js": function (exports, module, require) {
				// Whether given object is a promise

				'use strict';

				module.exports = function (o) {
					return (typeof o === 'function') && (typeof o.then === 'function');
				};
			},
			"monitor.js": function (exports, module, require) {
				// Run if you want to monitor unresolved promises (in properly working
				// application there should be no promises that are never resolved)

				'use strict';

				var max        = Math.max
				  , callable   = require('es5-ext/lib/Object/valid-callable')
				  , isCallable = require('es5-ext/lib/Object/is-callable')
				  , toUint     = require('es5-ext/lib/Number/to-uint')
				  , deferred   = require('./deferred');

				exports = module.exports = function (timeout, cb) {
					if (timeout === false) {
						// Cancel monitor
						delete deferred._monitor;
						delete exports.timeout;
						delete exports.callback;
						return;
					}
					exports.timeout = timeout = max(toUint(timeout) || 5000, 50);
					if (cb == null) {
						if ((typeof console !== 'undefined') && console &&
								isCallable(console.error)) {
							cb = function (e) {
								console.error(((e.stack && e.stack.toString()) ||
									"Unresolved promise: no stack available"));
							};
						}
					} else {
						callable(cb);
					}
					exports.callback = cb;

					deferred._monitor = function () {
						var e = new Error("Unresolved promise");
						return setTimeout(function () {
							cb && cb(e);
						}, timeout);
					};
				};
			},
			"profiler.js": function (exports, module, require) {
				'use strict';

				var partial  = require('es5-ext/lib/Function/prototype/partial')
				  , forEach  = require('es5-ext/lib/Object/for-each')
				  , pad      = require('es5-ext/lib/String/prototype/pad')
				  , deferred = require('./deferred')

				  , resolved, rStats, unresolved, uStats, profile;

				exports.profile = function () {
					resolved = 0;
					rStats = {};
					unresolved = 0;
					uStats = {};
					deferred._profile = profile;
				};

				profile = function (isResolved) {
					var stack, data;

					if (isResolved) {
						++resolved;
						data = rStats;
					} else {
						++unresolved;
						data = uStats;
					}

					stack = (new Error()).stack;
					if (!stack.split('\n').slice(3).some(function (line) {
							if ((line.search(/[\/\\]deferred[\/\\]/) === -1) &&
									(line.search(/[\/\\]es5-ext[\/\\]/) === -1) &&
									(line.indexOf(' (native)') === -1)) {
								line = line.replace(/\n/g, "\\n").trim();
								if (!data[line]) {
									data[line] = { count: 0 };
								}
								++data[line].count;
								return true;
							}
						})) {
						if (!data.unknown) {
							data.unknown = { count: 0, stack: stack };
						}
						++data.unknown.count;
					}
				};

				exports.profileEnd = function () {
					var total, lpad, log = '';

					if (!deferred._profile) {
						throw new Error("Deferred profiler was not initialized");
					}
					delete deferred._profile;

					log += "------------------------------------------------------------\n";
					log += "Deferred usage statistics:\n\n";

					total = String(resolved + unresolved);
					lpad = partial.call(pad, " ", total.length);
					log += total + " Total promises initialized\n";
					log += lpad.call(unresolved) + " Initialized as Unresolved\n";
					log += lpad.call(resolved) + " Initialized as Resolved\n";

					if (unresolved) {
						log += "\nUnresolved promises were initialized at:\n";
						forEach(uStats, function (data, name) {
							log += lpad.call(data.count) + " " + name + "\n";
						}, null, function (a, b) {
							return this[b].count - this[a].count;
						});
					}

					if (resolved) {
						log += "\nResolved promises were initialized at:\n";
						forEach(rStats, function (data, name) {
							log += lpad.call(data.count) + " " + name + "\n";
						}, null, function (a, b) {
							return this[b].count - this[a].count;
						});
					}
					log += "------------------------------------------------------------\n";

					return {
						log: log,
						resolved: { count: resolved, stats: rStats },
						unresolved: { count: unresolved, stats: uStats }
					};
				};
			},
			"valid-promise.js": function (exports, module, require) {
				'use strict';

				var isPromise = require('./is-promise');

				module.exports = function (x) {
					if (!isPromise(x)) {
						throw new TypeError(x + " is not a promise object");
					}
					return x;
				};
			}
		}
	},
	"es5-ext": {
		":mainpath:": "lib",
		"lib": {
			"Array": {
				"from.js": function (exports, module, require) {
					'use strict';

					var isArguments   = require('../Function/is-arguments')

					  , isArray = Array.isArray, slice = Array.prototype.slice;

					module.exports = function (obj) {
						if (isArray(obj)) {
							return obj;
						} else if (isArguments(obj)) {
							return (obj.length === 1) ? [obj[0]] : Array.apply(null, obj);
						} else {
							return slice.call(obj);
						}
					};
				},
				"of.js": function (exports, module, require) {
					'use strict';

					var slice = Array.prototype.slice;

					module.exports = function (/*…items*/) {
						return slice.call(arguments);
					};
				}
			},
			"Error": {
				"is-error.js": function (exports, module, require) {
					'use strict';

					var toString = Object.prototype.toString

					  , id = toString.call(new Error())
					  , exceptionRe = /^\[object [a-zA-z0-9]*(?:Exception|Error)\]$/;

					module.exports = function (x) {
						var xid;
						return (x && ((x instanceof Error) || ((xid = toString.call(x)) === id) ||
							xid.match(exceptionRe))) || false;
					};
				},
				"valid-error.js": function (exports, module, require) {
					'use strict';

					var isError = require('./is-error');

					module.exports = function (x) {
						if (!isError(x)) {
							throw new TypeError(x + " is not an Error object");
						}
						return x;
					};
				}
			},
			"Function": {
				"is-arguments.js": function (exports, module, require) {
					'use strict';

					var toString = Object.prototype.toString

					  , id = toString.call((function () { return arguments; }()));

					module.exports = function (x) {
						return toString.call(x) === id;
					};
				},
				"noop.js": function (exports, module, require) {
					'use strict';

					module.exports = function () {};
				},
				"prototype": {
					"match.js": function (exports, module, require) {
						'use strict';

						var callable = require('../../Object/valid-callable')

						  , apply = Function.prototype.apply;

						module.exports = function () {
							var fn = callable(this);
							return function (args) {
								return apply.call(fn, this, args);
							};
						};
					},
					"partial.js": function (exports, module, require) {
						'use strict';

						var callable = require('../../Object/valid-callable')
						  , toArray  = require('../../Array/from')

						  , apply = Function.prototype.apply;

						module.exports = function (/*…args*/) {
							var fn = callable(this)
							  , args = toArray(arguments);

							return function () {
								return apply.call(fn, this, args.concat(toArray(arguments)));
							};
						};
					}
				}
			},
			"Math": {
				"sign.js": function (exports, module, require) {
					'use strict';

					module.exports = function (value) {
						value = Number(value);
						if (isNaN(value) || (value === 0)) {
							return value;
						}
						return (value > 0) ? 1 : -1;
					};
				}
			},
			"Number": {
				"to-int.js": function (exports, module, require) {
					'use strict';

					var sign = require('../Math/sign')

					  , abs = Math.abs, floor = Math.floor;

					module.exports = function (value) {
						if (isNaN(value)) {
							return 0;
						}
						value = Number(value);
						if ((value === 0) || !isFinite(value)) {
							return value;
						}

						return sign(value) * floor(abs(value));
					};
				},
				"to-uint.js": function (exports, module, require) {
					'use strict';

					var toInt = require('./to-int')

					  , max = Math.max;

					module.exports = function (value) { return max(0, toInt(value)); };
				}
			},
			"Object": {
				"_iterate.js": function (exports, module, require) {
					// Internal method, used by iteration functions.
					// Calls a function for each key-value pair found in object
					// Optionally takes compareFn to iterate object in specific order

					'use strict';

					var isCallable = require('./is-callable')
					  , callable   = require('./valid-callable')
					  , value      = require('./valid-value')

					  , call = Function.prototype.call, keys = Object.keys;

					module.exports = function (method) {
						return function (obj, cb/*, thisArg, compareFn*/) {
							var list, thisArg = arguments[2], compareFn = arguments[3];
							obj = Object(value(obj));
							callable(cb);

							list = keys(obj);
							if (compareFn) {
								list.sort(isCallable(compareFn) ? compareFn.bind(obj) : undefined);
							}
							return list[method](function (key, index) {
								return call.call(cb, thisArg, obj[key], key, obj, index);
							});
						};
					};
				},
				"copy.js": function (exports, module, require) {
					'use strict';

					var isPlainObject = require('./is-plain-object')
					  , forEach       = require('./for-each')
					  , extend        = require('./extend')
					  , value         = require('./valid-value')

					  , recursive;

					recursive = function (to, from, cloned) {
						forEach(from, function (value, key) {
							var index;
							if (isPlainObject(value)) {
								if ((index = cloned[0].indexOf(value)) === -1) {
									cloned[0].push(value);
									cloned[1].push(to[key] = extend({}, value));
									recursive(to[key], value, cloned);
								} else {
									to[key] = cloned[1][index];
								}
							}
						}, from);
					};

					module.exports = function (obj/*, deep*/) {
						var copy;
						if ((copy = Object(value(obj))) === obj) {
							copy = extend({}, obj);
							if (arguments[1]) {
								recursive(copy, obj, [[obj], [copy]]);
							}
						}
						return copy;
					};
				},
				"descriptor.js": function (exports, module, require) {
					'use strict';

					var isCallable = require('./is-callable')
					  , callable   = require('./valid-callable')
					  , validValue = require('./valid-value')
					  , copy       = require('./copy')
					  , map        = require('./map')
					  , isString   = require('../String/is-string')
					  , contains   = require('../String/prototype/contains')

					  , bind = Function.prototype.bind
					  , defineProperty = Object.defineProperty
					  , d;

					d = module.exports = function (dscr, value) {
						var c, e, w;
						if (arguments.length < 2) {
							value = dscr;
							dscr = null;
						}
						if (dscr == null) {
							c = w = true;
							e = false;
						} else {
							c = contains.call(dscr, 'c');
							e = contains.call(dscr, 'e');
							w = contains.call(dscr, 'w');
						}

						return { value: value, configurable: c, enumerable: e, writable: w };
					};

					d.gs = function (dscr, get, set) {
						var c, e;
						if (isCallable(dscr)) {
							set = (get == null) ? undefined : callable(get);
							get = dscr;
							dscr = null;
						} else {
							get = (get == null) ? undefined : callable(get);
							set = (set == null) ? undefined : callable(set);
						}
						if (dscr == null) {
							c = true;
							e = false;
						} else {
							c = contains.call(dscr, 'c');
							e = contains.call(dscr, 'e');
						}

						return { get: get, set: set, configurable: c, enumerable: e };
					};

					d.binder = function self(name, dv) {
						var value, dgs;
						if (!isString(name)) {
							return map(name, function (dv, name) { return self(name, dv); });
						}
						value = validValue(dv) && callable(dv.value);
						dgs = copy(dv);
						delete dgs.writable;
						delete dgs.value;
						dgs.get = function () {
							dv.value = bind.call(value, this);
							defineProperty(this, name, dv);
							return this[name];
						};
						return dgs;
					};
				},
				"extend.js": function (exports, module, require) {
					'use strict';

					var value = require('./valid-value')

					  , forEach = Array.prototype.forEach, slice = Array.prototype.slice
					  , keys = Object.keys

					  , extend;

					extend = function (src) {
						keys(Object(src)).forEach(function (key) {
							this[key] = src[key];
						}, this);
					};

					module.exports = function (dest/*, …src*/) {
						forEach.call(arguments, value);
						slice.call(arguments, 1).forEach(extend, dest);
						return dest;
					};
				},
				"for-each.js": function (exports, module, require) {
					'use strict';

					module.exports = require('./_iterate')('forEach');
				},
				"is-callable.js": function (exports, module, require) {
					// Inspired by: http://www.davidflanagan.com/2009/08/typeof-isfuncti.html

					'use strict';

					var forEach = Array.prototype.forEach.bind([]);

					module.exports = function (obj) {
						var type;
						if (!obj) {
							return false;
						}
						type = typeof obj;
						if (type === 'function') {
							return true;
						}
						if (type !== 'object') {
							return false;
						}

						try {
							forEach(obj);
							return true;
						} catch (e) {
							if (e instanceof TypeError) {
								return false;
							}
							throw e;
						}
					};
				},
				"is-plain-object.js": function (exports, module, require) {
					'use strict';

					var getPrototypeOf = Object.getPrototypeOf, prototype = Object.prototype
					  , toString = prototype.toString

					  , id = {}.toString();

					module.exports = function (value) {
						var proto;
						if (!value || (typeof value !== 'object') || (toString.call(value) !== id)) {
							return false;
						}
						proto = getPrototypeOf(value);
						return (proto === prototype) || (getPrototypeOf(proto) === null);
					};
				},
				"map.js": function (exports, module, require) {
					'use strict';

					var callable = require('./valid-callable')
					  , forEach  = require('./for-each')

					  , call = Function.prototype.call;

					module.exports = function (obj, cb/*, thisArg*/) {
						var o = {}, thisArg = arguments[2];
						callable(cb);
						forEach(obj, function (value, key, obj, index) {
							o[key] = call.call(cb, thisArg, value, key, obj, index);
						});
						return o;
					};
				},
				"valid-callable.js": function (exports, module, require) {
					'use strict';

					var isCallable = require('./is-callable');

					module.exports = function (fn) {
						if (!isCallable(fn)) {
							throw new TypeError(fn + " is not a function");
						}
						return fn;
					};
				},
				"valid-value.js": function (exports, module, require) {
					'use strict';

					module.exports = function (value) {
						if (value == null) {
							throw new TypeError("Cannot use null or undefined");
						}
						return value;
					};
				}
			},
			"String": {
				"is-string.js": function (exports, module, require) {
					'use strict';

					var toString = Object.prototype.toString

					  , id = toString.call('');

					module.exports = function (x) {
						return (typeof x === 'string') || (x && (typeof x === 'object') &&
							((x instanceof String) || (toString.call(x) === id))) || false;
					};
				},
				"prototype": {
					"contains.js": function (exports, module, require) {
						'use strict';

						var indexOf = String.prototype.indexOf;

						module.exports = function (searchString/*, position*/) {
							return indexOf.call(this, searchString, arguments[1]) > -1;
						};
					},
					"pad.js": function (exports, module, require) {
						'use strict';

						var toInt  = require('../../Number/to-int')
						  , value  = require('../../Object/valid-value')
						  , repeat = require('./repeat')

						  , abs = Math.abs, max = Math.max;

						module.exports = function (fill/*, length*/) {
							var self = String(value(this))
							  , sLength = self.length
							  , length = arguments[1];

							length = isNaN(length) ? 1 : toInt(length);
							fill = repeat.call(String(fill), abs(length));
							if (length >= 0) {
								return fill.slice(0, max(0, length - sLength)) + self;
							} else {
								return self + (((sLength + length) >= 0) ? '' :
										fill.slice(length + sLength));
							}
						};
					},
					"repeat.js": function (exports, module, require) {
						// Not rocket science but taken from:
						// http://closure-library.googlecode.com/svn/trunk/closure/goog/string/string.js

						'use strict';

						var value  = require('../../Object/valid-value')
						  , toUint = require('../../Number/to-uint');

						module.exports = function (n) {
							return new Array((isNaN(n) ? 1 : toUint(n)) + 1).join(String(value(this)));
						};
					}
				}
			}
		}
	},
	"event-emitter": {
		":mainpath:": "lib",
		"lib": {
			"_id.js": function (exports, module, require) {
				'use strict';

				module.exports = '_ee2_';
			},
			"core.js": function (exports, module, require) {
				'use strict';

				var d        = require('es5-ext/lib/Object/descriptor')
				  , callable = require('es5-ext/lib/Object/valid-callable')
				  , id       = require('./_id')

				  , apply = Function.prototype.apply, call = Function.prototype.call
				  , create = Object.create, defineProperty = Object.defineProperty
				  , defineProperties = Object.defineProperties
				  , descriptor = { configurable: true, enumerable: false, writable: true }

				  , on, once, off, emit
				  , colId, methods, descriptors, base;

				colId = id + 'l_';

				on = function (type, listener) {
					var data;

					callable(listener);

					if (!this.hasOwnProperty(id)) {
						data = descriptor.value = {};
						defineProperty(this, id, descriptor);
						descriptor.value = null;
					} else {
						data = this[id];
					}
					if (!data.hasOwnProperty(type)) data[type] = listener;
					else if (data[type].hasOwnProperty(colId)) data[type].push(listener);
					else (data[type] = [data[type], listener])[colId] = true;

					return this;
				};

				once = function (type, listener) {
					var once, self;

					callable(listener);
					self = this;
					on.call(this, type, once = function () {
						off.call(self, type, once);
						apply.call(listener, this, arguments);
					});

					once._listener = listener;
					return this;
				};

				off = function (type, listener) {
					var data, listeners, candidate, i;

					callable(listener);

					if (!this.hasOwnProperty(id)) return this;
					data = this[id];
					if (!data.hasOwnProperty(type)) return this;
					listeners = data[type];

					if (listeners.hasOwnProperty(colId)) {
						for (i = 0; (candidate = listeners[i]); ++i) {
							if ((candidate === listener) || (candidate._listener === listener)) {
								if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
								else listeners.splice(i, 1);
							}
						}
					} else {
						if ((listeners === listener) || (listeners._listener === listener)) {
							delete data[type];
						}
					}

					return this;
				};

				emit = function (type) {
					var data, i, l, listener, listeners, args;

					if (!this.hasOwnProperty(id)) return;
					data = this[id];
					if (!data.hasOwnProperty(type)) return;
					listeners = data[type];

					if (listeners.hasOwnProperty(colId)) {
						l = arguments.length;
						args = new Array(l - 1);
						for (i = 1; i < l; ++i) {
							args[i - 1] = arguments[i];
						}

						listeners = listeners.slice();
						for (i = 0; (listener = listeners[i]); ++i) {
							apply.call(listener, this, args);
						}
					} else {
						switch (arguments.length) {
						case 1:
							call.call(listeners, this);
							break;
						case 2:
							call.call(listeners, this, arguments[1]);
							break;
						case 3:
							call.call(listeners, this, arguments[1], arguments[2]);
							break;
						default:
							l = arguments.length;
							args = new Array(l - 1);
							for (i = 1; i < l; ++i) {
								args[i - 1] = arguments[i];
							}
							apply.call(listeners, this, args);
						}
					}
				};

				methods = {
					on: on,
					once: once,
					off: off,
					emit: emit
				};

				descriptors = {
					on: d(on),
					once: d(once),
					off: d(off),
					emit: d(emit)
				};

				base = defineProperties({}, descriptors);

				module.exports = exports = function (o) {
					return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
				};
				exports.methods = methods;
			},
			"unify.js": function (exports, module, require) {
				'use strict';

				var forEach    = require('es5-ext/lib/Object/for-each')
				  , validValue = require('es5-ext/lib/Object/valid-value')
				  , id         = require('./_id')

				  , push = Array.prototype.apply, defineProperty = Object.defineProperty
				  , d = { configurable: true, enumerable: false, writable: true }
				  , colId = id + 'l_';

				module.exports = function (e1, e2) {
					var data;
					validValue(e1) && validValue(e2);
					if (!e1.hasOwnProperty(id)) {
						if (!e2.hasOwnProperty(id)) {
							d.value = {};
							defineProperty(e1, id, d);
							defineProperty(e2, id, d);
							d.value = null;
							return;
						}
						d.value = e2[id];
						defineProperty(e1, id, d);
						d.value = null;
						return;
					}
					data = d.value = e1[id];
					if (!e2.hasOwnProperty(id)) {
						defineProperty(e2, id, d);
						d.value = null;
						return;
					}
					if (data === e2[id]) return;
					forEach(e2[id], function (listener, name) {
						if (!data.hasOwnProperty(name)) {
							data[name] = listener;
							return;
						}
						if (data[name].hasOwnProperty(colId)) {
							if (listener.hasOwnProperty(colId)) push.apply(data[name], listener);
							else data[name].push(listener);
						} else if (listener.hasOwnProperty(colId)) {
							listener.unshift(data[name]);
							data[name] = listener;
						} else {
							(data[name] = [data[name], listener])[colId] = true;
						}
					});
					defineProperty(e2, id, d);
					d.value = null;
				};
			}
		}
	},
	"next-tick": {
		":mainpath:": "lib/next-tick",
		"lib": {
			"next-tick.js": function (exports, module, require) {
				'use strict';

				if ((typeof process !== 'undefined') && process &&
						(typeof process.nextTick === 'function')) {

					// Node.js
					module.exports = process.nextTick;

				} else if (typeof setImmediate === 'function') {

					// W3C Draft
					// https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
					module.exports = function (cb) { setImmediate(cb); };

				} else {

					// Wide available standard
					module.exports = function (cb) { setTimeout(cb, 0); };
				}
			}
		}
	}
})("deferred/lib/index");
});
